Index: include/synchronizer.h
===================================================================
--- include/synchronizer.h	(revision 4529)
+++ include/synchronizer.h	(working copy)
@@ -11,7 +11,11 @@
 class Synchronizer_Common
 {
 protected:
+    typedef Thread::Queue Queue;
+
+protected:
     Synchronizer_Common() {}
+    ~Synchronizer_Common() {begin_atomic(); wakeup_all();}
 
     // Atomic operations
     bool tsl(volatile bool & lock) { return CPU::tsl(lock); }
@@ -22,9 +26,12 @@
     void begin_atomic() { Thread::lock(); }
     void end_atomic() { Thread::unlock(); }
 
-    void sleep() { Thread::yield(); } // implicit unlock()
-    void wakeup() { end_atomic(); }
-    void wakeup_all() { end_atomic(); }
+    void sleep() { Thread::sleep(&_queue); }
+    void wakeup() { Thread::wakeup(&_queue); }
+    void wakeup_all() { Thread::wakeup_all(&_queue); }
+
+protected:
+    Queue _queue;
 };
 
 __END_SYS
Index: include/system/config.h
===================================================================
--- include/system/config.h	(revision 4529)
+++ include/system/config.h	(working copy)
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define MODE xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define MODE library
+#define ARCH ia32
+#define MACH pc
+#define MMOD legacy
+#define APPL philosophers_dinner
+#define __mode_library__
+#define __arch_ia32__
+#define __mach_pc__
+#define __mmod_legacy__
 
 #if defined (__arch_avr__) || defined (__mmod_lm3s811__)
 #define __no_networking__
Index: include/thread.h
===================================================================
--- include/thread.h	(revision 4529)
+++ include/thread.h	(working copy)
@@ -12,6 +12,8 @@
 
 __BEGIN_SYS
 
+class IdleThread;
+
 class Thread
 {
     friend class Init_First;
@@ -45,7 +47,8 @@
     enum {
         HIGH = 0,
         NORMAL = 15,
-        LOW = 31
+        LOW = 31,
+        IDLE = -1
     };
 
     // Thread Configuration
@@ -92,12 +95,15 @@
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
 
+    static void sleep(Queue * q);
+    static void wakeup(Queue * q);
+    static void wakeup_all(Queue * q);
+
     static void reschedule();
     static void time_slicer(const IC::Interrupt_Id & interrupt);
 
     static void dispatch(Thread * prev, Thread * next);
 
-    static int idle();
 
 private:
     static void init();
@@ -106,6 +112,7 @@
     char * _stack;
     Context * volatile _context;
     volatile State _state;
+    Queue * _waiting;
     Queue::Element _link;
 
     static Scheduler_Timer * _timer;
@@ -113,13 +120,15 @@
 private:
     static Thread * volatile _running;
     static Queue _ready;
+    static Thread * _idleThread;
     static Queue _suspended;
+    Queue _joining;
 };
 
 
 template<typename ... Tn>
 inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
-: _state(READY), _link(this, NORMAL)
+: _state(READY), _waiting(0), _link(this, NORMAL)
 {
     constructor_prolog(STACK_SIZE);
     _context = CPU::init_stack(_stack + STACK_SIZE, &__exit, entry, an ...);
@@ -128,7 +137,7 @@
 
 template<typename ... Tn>
 inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _link(this, conf.priority)
+: _state(conf.state), _waiting(0), _link(this, conf.priority)
 {
     constructor_prolog(conf.stack_size);
     _context = CPU::init_stack(_stack + conf.stack_size, &__exit, entry, an ...);
Index: src/abstraction/mutex.cc
===================================================================
--- src/abstraction/mutex.cc	(revision 4529)
+++ src/abstraction/mutex.cc	(working copy)
@@ -22,8 +22,7 @@
 
     begin_atomic();
     if(tsl(_locked))
-        while(tsl(_locked))
-            sleep(); // implicit end_atomic()
+        sleep();
     else
         end_atomic();
 }
@@ -34,8 +33,13 @@
     db<Synchronizer>(TRC) << "Mutex::unlock(this=" << this << ")" << endl;
 
     begin_atomic();
-    _locked = false;
-    wakeup(); // implicit end_atomic()
+    if (_queue.empty()) {
+        _locked = false;
+        end_atomic();
+    }
+    else {
+        wakeup();
+    }
 }
 
 __END_SYS
Index: src/abstraction/semaphore.cc
===================================================================
--- src/abstraction/semaphore.cc	(revision 4529)
+++ src/abstraction/semaphore.cc	(working copy)
@@ -20,9 +20,11 @@
 {
     db<Synchronizer>(TRC) << "Semaphore::p(this=" << this << ",value=" << _value << ")" << endl;
 
-    fdec(_value);
-    while(_value < 0)
+    begin_atomic();
+    if(fdec(_value) < 1)
         sleep();
+    else
+        end_atomic();
 }
 
 
@@ -30,9 +32,12 @@
 {
     db<Synchronizer>(TRC) << "Semaphore::v(this=" << this << ",value=" << _value << ")" << endl;
 
-    finc(_value);
-    if(_value < 1)
+    begin_atomic();
+    if (finc(_value) < 0)
         wakeup();
+    else
+        end_atomic();
+
 }
 
 __END_SYS
Index: src/abstraction/thread.cc
===================================================================
--- src/abstraction/thread.cc	(revision 4529)
+++ src/abstraction/thread.cc	(working copy)
@@ -3,6 +3,7 @@
 #include <system/kmalloc.h>
 #include <machine.h>
 #include <thread.h>
+#include <idle_thread.h>
 
 // This_Thread class attributes
 __BEGIN_UTIL
@@ -17,6 +18,7 @@
 Thread* volatile Thread::_running;
 Thread::Queue Thread::_ready;
 Thread::Queue Thread::_suspended;
+Thread* Thread::_idleThread;
 
 // Methods
 void Thread::constructor_prolog(unsigned int stack_size)
@@ -26,7 +28,6 @@
     _stack = reinterpret_cast<char *>(kmalloc(stack_size));
 }
 
-
 void Thread::constructor_epilog(const Log_Addr & entry, unsigned int stack_size)
 {
     db<Thread>(TRC) << "Thread(entry=" << entry
@@ -46,7 +47,6 @@
     unlock();
 }
 
-
 Thread::~Thread()
 {
     lock();
@@ -61,12 +61,14 @@
     _ready.remove(this);
     _suspended.remove(this);
 
+    if (_waiting)
+        _waiting->remove(this);
+
     unlock();
 
     kfree(_stack);
 }
 
-
 int Thread::join()
 {
     lock();
@@ -73,8 +75,14 @@
 
     db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
 
-    while(_state != FINISHING)
-        yield(); // implicit unlock()
+    while (_state != FINISHING) {
+      Thread * prev = _running;
+      prev->_state = WAITING;
+      this->_joining.insert(&prev->_link);
+      _running = _ready.remove()->object();
+      _running->_state = RUNNING;
+      dispatch(prev, _running);
+    }
 
     unlock();
 
@@ -81,7 +89,6 @@
     return *reinterpret_cast<int *>(_stack);
 }
 
-
 void Thread::pass()
 {
     lock();
@@ -101,7 +108,6 @@
     unlock();
 }
 
-
 void Thread::suspend()
 {
     lock();
@@ -114,18 +120,16 @@
     _state = SUSPENDED;
     _suspended.insert(&_link);
 
-    if((_running == this) && !_ready.empty()) {
+    if(_running == this) {
         _running = _ready.remove()->object();
         _running->_state = RUNNING;
 
         dispatch(this, _running);
-    } else
-        idle(); // implicit unlock()
+    }
 
     unlock();
 }
 
-
 void Thread::resume()
 {
     lock();
@@ -139,7 +143,6 @@
    unlock();
 }
 
-
 // Class methods
 void Thread::yield()
 {
@@ -147,22 +150,16 @@
 
     db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
 
-    if(!_ready.empty()) {
-        Thread * prev = _running;
-        prev->_state = READY;
-        _ready.insert(&prev->_link);
+    Thread * prev = _running;
+    prev->_state = READY;
+    _ready.insert(&prev->_link);
+    _running = _ready.remove()->object();
+    _running->_state = RUNNING;
+    dispatch(prev, _running);
 
-        _running = _ready.remove()->object();
-        _running->_state = RUNNING;
-
-        dispatch(prev, _running);
-    } else
-        idle();
-
     unlock();
 }
 
-
 void Thread::exit(int status)
 {
     lock();
@@ -169,12 +166,18 @@
 
     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    while(_ready.empty() && !_suspended.empty())
-        idle(); // implicit unlock();
+    while (_ready.size() == 1 && !_suspended.empty())
+        yield(); // idle thread  // implicit unlock();
 
     lock();
 
-    if(!_ready.empty()) {
+    while (!_running->_joining.empty()) {
+        Thread* joined = _running->_joining.remove()->object();
+        joined->_state = READY;
+        _ready.insert(&joined->_link);
+    }
+
+    if(_ready.size() > 1) {
         Thread * prev = _running;
         prev->_state = FINISHING;
         *reinterpret_cast<int *>(prev->_stack) = status;
@@ -197,7 +200,64 @@
     unlock();
 }
 
+void Thread::sleep(Queue * q) {
 
+    db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
+
+    assert(locked());
+
+    Thread * prev = running();
+    prev->_state = WAITING;
+    prev->_waiting = q;
+    q->insert(&prev->_link);
+
+    _running = _ready.remove()->object();
+    _running->_state = RUNNING;
+
+    dispatch(prev, _running);
+
+    unlock();
+}
+
+void Thread::wakeup(Queue * q) {
+
+    db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
+
+    assert(locked());
+
+    if (!q->empty()) {
+        Thread * t = q->remove()->object();
+        t->_state = READY;
+        t->_waiting = 0;
+        _ready.insert(&t->_link);
+    }
+
+    unlock();
+
+    if (preemptive)
+        reschedule();
+
+}
+
+void Thread::wakeup_all(Queue * q) {
+
+    db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
+
+    assert(locked());
+
+    while (!q->empty()) {
+        Thread * t = q->remove()->object();
+        t->_state = READY;
+        t->_waiting = 0;
+        _ready.insert(&t->_link);
+    }
+
+    unlock();
+
+    if (preemptive)
+        reschedule();
+}
+
 void Thread::reschedule()
 {
     yield();
@@ -227,20 +287,6 @@
     unlock();
 }
 
-
-int Thread::idle()
-{
-    db<Thread>(TRC) << "Thread::idle()" << endl;
-
-    db<Thread>(INF) << "There are no runnable threads at the moment!" << endl;
-    db<Thread>(INF) << "Halting the CPU ..." << endl;
-
-    CPU::int_enable();
-    CPU::halt();
-
-    return 0;
-}
-
 __END_SYS
 
 // Id forwarder to the spin lock
Index: src/abstraction/thread_init.cc
===================================================================
--- src/abstraction/thread_init.cc	(revision 4529)
+++ src/abstraction/thread_init.cc	(working copy)
@@ -3,6 +3,7 @@
 #include <system/kmalloc.h>
 #include <system.h>
 #include <thread.h>
+#include <idle_thread.h>
 #include <alarm.h>
 
 __BEGIN_SYS
@@ -17,6 +18,9 @@
     // neither by IDLE (which has a lower priority)
     if(preemptive)
         _timer = new (kmalloc(sizeof(Scheduler_Timer))) Scheduler_Timer(QUANTUM, time_slicer);
+    Thread idleThread = IdleThread();
+    Thread::_idleThread = &idleThread;
+    Thread::_ready.insert(&Thread::_idleThread->_link);
 }
 
 __END_SYS
